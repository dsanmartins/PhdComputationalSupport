/*
 * generated by Xtext 2.10.0
 */
package br.ufscar.sas.xtext.sasdsl.serializer;

import br.ufscar.sas.xtext.sasdsl.sasDsl.ArchitectureDefinition;
import br.ufscar.sas.xtext.sasdsl.sasDsl.BasicType;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Can;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Cannot;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAnalyzerBelongsTo1;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAnalyzerBelongsTo2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLClBelongsTo1;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLClBelongsTo2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLClmBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLControlLoop;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLControlLoopManager;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLEffector;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLEffectorBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLExecutorBelongsTo1;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLExecutorBelongsTo2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLGauge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLGaugeBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLKnowledge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaged;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaging;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMeasuredOuputBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMeasuredOutput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMonitorBelongsTo1;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMonitorBelongsTo2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLPlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLPlannerBelongsTo1;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLPlannerBelongsTo2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLProbe;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLProbeBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLReferenceInput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLReferenceInputBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRestriction;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLSensor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLSensorBelongsTo;
import br.ufscar.sas.xtext.sasdsl.sasDsl.EntityType;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Must;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Only;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Only2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.SasDslPackage;
import br.ufscar.sas.xtext.sasdsl.services.SasDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SasDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SasDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SasDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SasDslPackage.ARCHITECTURE_DEFINITION:
				sequence_ArchitectureDefinition(context, (ArchitectureDefinition) semanticObject); 
				return; 
			case SasDslPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case SasDslPackage.CAN:
				sequence_Can(context, (Can) semanticObject); 
				return; 
			case SasDslPackage.CANNOT:
				sequence_Cannot(context, (Cannot) semanticObject); 
				return; 
			case SasDslPackage.DSL_ANALYZER:
				sequence_DSLAnalyzer(context, (DSLAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DSL_ANALYZER_BELONGS_TO1:
				sequence_DSLAnalyzerBelongsTo1(context, (DSLAnalyzerBelongsTo1) semanticObject); 
				return; 
			case SasDslPackage.DSL_ANALYZER_BELONGS_TO2:
				sequence_DSLAnalyzerBelongsTo2(context, (DSLAnalyzerBelongsTo2) semanticObject); 
				return; 
			case SasDslPackage.DSL_CL_BELONGS_TO1:
				sequence_DSLClBelongsTo1(context, (DSLClBelongsTo1) semanticObject); 
				return; 
			case SasDslPackage.DSL_CL_BELONGS_TO2:
				sequence_DSLClBelongsTo2(context, (DSLClBelongsTo2) semanticObject); 
				return; 
			case SasDslPackage.DSL_CLM_BELONGS_TO:
				sequence_DSLClmBelongsTo(context, (DSLClmBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_CONTROL_LOOP:
				sequence_DSLControlLoop(context, (DSLControlLoop) semanticObject); 
				return; 
			case SasDslPackage.DSL_CONTROL_LOOP_MANAGER:
				sequence_DSLControlLoopManager(context, (DSLControlLoopManager) semanticObject); 
				return; 
			case SasDslPackage.DSL_EFFECTOR:
				sequence_DSLEffector(context, (DSLEffector) semanticObject); 
				return; 
			case SasDslPackage.DSL_EFFECTOR_BELONGS_TO:
				sequence_DSLEffectorBelongsTo(context, (DSLEffectorBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_EXECUTOR:
				sequence_DSLExecutor(context, (DSLExecutor) semanticObject); 
				return; 
			case SasDslPackage.DSL_EXECUTOR_BELONGS_TO1:
				sequence_DSLExecutorBelongsTo1(context, (DSLExecutorBelongsTo1) semanticObject); 
				return; 
			case SasDslPackage.DSL_EXECUTOR_BELONGS_TO2:
				sequence_DSLExecutorBelongsTo2(context, (DSLExecutorBelongsTo2) semanticObject); 
				return; 
			case SasDslPackage.DSL_GAUGE:
				sequence_DSLGauge(context, (DSLGauge) semanticObject); 
				return; 
			case SasDslPackage.DSL_GAUGE_BELONGS_TO:
				sequence_DSLGaugeBelongsTo(context, (DSLGaugeBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_KNOWLEDGE:
				sequence_DSLKnowledge(context, (DSLKnowledge) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGED:
				sequence_DSLManaged(context, (DSLManaged) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGING:
				sequence_DSLManaging(context, (DSLManaging) semanticObject); 
				return; 
			case SasDslPackage.DSL_MEASURED_OUPUT_BELONGS_TO:
				sequence_DSLMeasuredOuputBelongsTo(context, (DSLMeasuredOuputBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_MEASURED_OUTPUT:
				sequence_DSLMeasuredOutput(context, (DSLMeasuredOutput) semanticObject); 
				return; 
			case SasDslPackage.DSL_MONITOR:
				sequence_DSLMonitor(context, (DSLMonitor) semanticObject); 
				return; 
			case SasDslPackage.DSL_MONITOR_BELONGS_TO1:
				sequence_DSLMonitorBelongsTo1(context, (DSLMonitorBelongsTo1) semanticObject); 
				return; 
			case SasDslPackage.DSL_MONITOR_BELONGS_TO2:
				sequence_DSLMonitorBelongsTo2(context, (DSLMonitorBelongsTo2) semanticObject); 
				return; 
			case SasDslPackage.DSL_PLANNER:
				sequence_DSLPlanner(context, (DSLPlanner) semanticObject); 
				return; 
			case SasDslPackage.DSL_PLANNER_BELONGS_TO1:
				sequence_DSLPlannerBelongsTo1(context, (DSLPlannerBelongsTo1) semanticObject); 
				return; 
			case SasDslPackage.DSL_PLANNER_BELONGS_TO2:
				sequence_DSLPlannerBelongsTo2(context, (DSLPlannerBelongsTo2) semanticObject); 
				return; 
			case SasDslPackage.DSL_PROBE:
				sequence_DSLProbe(context, (DSLProbe) semanticObject); 
				return; 
			case SasDslPackage.DSL_PROBE_BELONGS_TO:
				sequence_DSLProbeBelongsTo(context, (DSLProbeBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_REFERENCE_INPUT:
				sequence_DSLReferenceInput(context, (DSLReferenceInput) semanticObject); 
				return; 
			case SasDslPackage.DSL_REFERENCE_INPUT_BELONGS_TO:
				sequence_DSLReferenceInputBelongsTo(context, (DSLReferenceInputBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.DSL_RESTRICTION:
				sequence_DSLRestriction(context, (DSLRestriction) semanticObject); 
				return; 
			case SasDslPackage.DSL_SENSOR:
				sequence_DSLSensor(context, (DSLSensor) semanticObject); 
				return; 
			case SasDslPackage.DSL_SENSOR_BELONGS_TO:
				sequence_DSLSensorBelongsTo(context, (DSLSensorBelongsTo) semanticObject); 
				return; 
			case SasDslPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case SasDslPackage.MUST:
				sequence_Must(context, (Must) semanticObject); 
				return; 
			case SasDslPackage.ONLY:
				sequence_Only(context, (Only) semanticObject); 
				return; 
			case SasDslPackage.ONLY2:
				sequence_Only2(context, (Only2) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArchitectureDefinition returns ArchitectureDefinition
	 *
	 * Constraint:
	 *     (abstractions+=DSLAbstraction+ compositions+=DSLComposition* restrictions+=DSLRestriction*)
	 */
	protected void sequence_ArchitectureDefinition(ISerializationContext context, ArchitectureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementType returns BasicType
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (typeName='access' | typeName='declare' | typeName='handle' | typeName='create' | typeName='depend')
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Can returns Can
	 *
	 * Constraint:
	 *     can='can-'
	 */
	protected void sequence_Can(ISerializationContext context, Can semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.CAN__CAN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.CAN__CAN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCanAccess().getCanCanKeyword_0(), semanticObject.getCan());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Cannot returns Cannot
	 *
	 * Constraint:
	 *     cannot='cannot-'
	 */
	protected void sequence_Cannot(ISerializationContext context, Cannot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.CANNOT__CANNOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.CANNOT__CANNOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCannotAccess().getCannotCannotKeyword_0(), semanticObject.getCannot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLAnalyzerBelongsTo1
	 *     DSLAnalyzerBelongsTo1 returns DSLAnalyzerBelongsTo1
	 *
	 * Constraint:
	 *     (analyzer=[DSLAnalyzer|ID] cl=[DSLControlLoop|ID])
	 */
	protected void sequence_DSLAnalyzerBelongsTo1(ISerializationContext context, DSLAnalyzerBelongsTo1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO1__ANALYZER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO1__ANALYZER));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO1__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO1__CL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLAnalyzerBelongsTo1Access().getAnalyzerDSLAnalyzerIDTerminalRuleCall_1_0_1(), semanticObject.getAnalyzer());
		feeder.accept(grammarAccess.getDSLAnalyzerBelongsTo1Access().getClDSLControlLoopIDTerminalRuleCall_3_0_1(), semanticObject.getCl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLAnalyzerBelongsTo2
	 *     DSLAnalyzerBelongsTo2 returns DSLAnalyzerBelongsTo2
	 *
	 * Constraint:
	 *     (analyzer=[DSLAnalyzer|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLAnalyzerBelongsTo2(ISerializationContext context, DSLAnalyzerBelongsTo2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO2__ANALYZER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO2__ANALYZER));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO2__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER_BELONGS_TO2__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLAnalyzerBelongsTo2Access().getAnalyzerDSLAnalyzerIDTerminalRuleCall_1_0_1(), semanticObject.getAnalyzer());
		feeder.accept(grammarAccess.getDSLAnalyzerBelongsTo2Access().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLAnalyzer
	 *     DSLAnalyzer returns DSLAnalyzer
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLAnalyzer(ISerializationContext context, DSLAnalyzer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLClBelongsTo1
	 *     DSLClBelongsTo1 returns DSLClBelongsTo1
	 *
	 * Constraint:
	 *     (cl=[DSLControlLoop|ID] clm=[DSLControlLoopManager|ID])
	 */
	protected void sequence_DSLClBelongsTo1(ISerializationContext context, DSLClBelongsTo1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO1__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO1__CL));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO1__CLM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO1__CLM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLClBelongsTo1Access().getClDSLControlLoopIDTerminalRuleCall_1_0_1(), semanticObject.getCl());
		feeder.accept(grammarAccess.getDSLClBelongsTo1Access().getClmDSLControlLoopManagerIDTerminalRuleCall_3_0_1(), semanticObject.getClm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLClBelongsTo2
	 *     DSLClBelongsTo2 returns DSLClBelongsTo2
	 *
	 * Constraint:
	 *     (cl=[DSLControlLoop|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLClBelongsTo2(ISerializationContext context, DSLClBelongsTo2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO2__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO2__CL));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO2__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CL_BELONGS_TO2__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLClBelongsTo2Access().getClDSLControlLoopIDTerminalRuleCall_1_0_1(), semanticObject.getCl());
		feeder.accept(grammarAccess.getDSLClBelongsTo2Access().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLClmBelongsTo
	 *     DSLClmBelongsTo returns DSLClmBelongsTo
	 *
	 * Constraint:
	 *     (cl=[DSLControlLoopManager|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLClmBelongsTo(ISerializationContext context, DSLClmBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CLM_BELONGS_TO__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CLM_BELONGS_TO__CL));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_CLM_BELONGS_TO__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_CLM_BELONGS_TO__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLClmBelongsToAccess().getClDSLControlLoopManagerIDTerminalRuleCall_1_0_1(), semanticObject.getCl());
		feeder.accept(grammarAccess.getDSLClmBelongsToAccess().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLControlLoopManager
	 *     DSLControlLoopManager returns DSLControlLoopManager
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLControlLoopManager(ISerializationContext context, DSLControlLoopManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLControlLoop
	 *     DSLControlLoop returns DSLControlLoop
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLControlLoop(ISerializationContext context, DSLControlLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLEffectorBelongsTo
	 *     DSLEffectorBelongsTo returns DSLEffectorBelongsTo
	 *
	 * Constraint:
	 *     (effector=[DSLEffector|ID] executor=[DSLExecutor|ID])
	 */
	protected void sequence_DSLEffectorBelongsTo(ISerializationContext context, DSLEffectorBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR_BELONGS_TO__EFFECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR_BELONGS_TO__EFFECTOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR_BELONGS_TO__EXECUTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR_BELONGS_TO__EXECUTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLEffectorBelongsToAccess().getEffectorDSLEffectorIDTerminalRuleCall_1_0_1(), semanticObject.getEffector());
		feeder.accept(grammarAccess.getDSLEffectorBelongsToAccess().getExecutorDSLExecutorIDTerminalRuleCall_3_0_1(), semanticObject.getExecutor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLEffector
	 *     DSLEffector returns DSLEffector
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLEffector(ISerializationContext context, DSLEffector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLExecutorBelongsTo1
	 *     DSLExecutorBelongsTo1 returns DSLExecutorBelongsTo1
	 *
	 * Constraint:
	 *     (executor=[DSLExecutor|ID] cl=[DSLControlLoop|ID])
	 */
	protected void sequence_DSLExecutorBelongsTo1(ISerializationContext context, DSLExecutorBelongsTo1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO1__EXECUTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO1__EXECUTOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO1__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO1__CL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLExecutorBelongsTo1Access().getExecutorDSLExecutorIDTerminalRuleCall_1_0_1(), semanticObject.getExecutor());
		feeder.accept(grammarAccess.getDSLExecutorBelongsTo1Access().getClDSLControlLoopIDTerminalRuleCall_3_0_1(), semanticObject.getCl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLExecutorBelongsTo2
	 *     DSLExecutorBelongsTo2 returns DSLExecutorBelongsTo2
	 *
	 * Constraint:
	 *     (executor=[DSLExecutor|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLExecutorBelongsTo2(ISerializationContext context, DSLExecutorBelongsTo2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO2__EXECUTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO2__EXECUTOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO2__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR_BELONGS_TO2__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLExecutorBelongsTo2Access().getExecutorDSLExecutorIDTerminalRuleCall_1_0_1(), semanticObject.getExecutor());
		feeder.accept(grammarAccess.getDSLExecutorBelongsTo2Access().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLExecutor
	 *     DSLExecutor returns DSLExecutor
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLExecutor(ISerializationContext context, DSLExecutor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLGaugeBelongsTo
	 *     DSLGaugeBelongsTo returns DSLGaugeBelongsTo
	 *
	 * Constraint:
	 *     (gauge=[DSLGauge|ID] managed=[DSLManaged|ID])
	 */
	protected void sequence_DSLGaugeBelongsTo(ISerializationContext context, DSLGaugeBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_GAUGE_BELONGS_TO__GAUGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_GAUGE_BELONGS_TO__GAUGE));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_GAUGE_BELONGS_TO__MANAGED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_GAUGE_BELONGS_TO__MANAGED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLGaugeBelongsToAccess().getGaugeDSLGaugeIDTerminalRuleCall_1_0_1(), semanticObject.getGauge());
		feeder.accept(grammarAccess.getDSLGaugeBelongsToAccess().getManagedDSLManagedIDTerminalRuleCall_3_0_1(), semanticObject.getManaged());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLGauge
	 *     DSLGauge returns DSLGauge
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLGauge(ISerializationContext context, DSLGauge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLKnowledge
	 *     DSLKnowledge returns DSLKnowledge
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLKnowledge(ISerializationContext context, DSLKnowledge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLManaged
	 *     DSLManaged returns DSLManaged
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLManaged(ISerializationContext context, DSLManaged semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLManaging
	 *     DSLManaging returns DSLManaging
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLManaging(ISerializationContext context, DSLManaging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLMeasuredOuputBelongsTo
	 *     DSLMeasuredOuputBelongsTo returns DSLMeasuredOuputBelongsTo
	 *
	 * Constraint:
	 *     (measured=[DSLMeasuredOutput|ID] managed=[DSLManaged|ID])
	 */
	protected void sequence_DSLMeasuredOuputBelongsTo(ISerializationContext context, DSLMeasuredOuputBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUPUT_BELONGS_TO__MEASURED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUPUT_BELONGS_TO__MEASURED));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUPUT_BELONGS_TO__MANAGED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUPUT_BELONGS_TO__MANAGED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMeasuredOuputBelongsToAccess().getMeasuredDSLMeasuredOutputIDTerminalRuleCall_1_0_1(), semanticObject.getMeasured());
		feeder.accept(grammarAccess.getDSLMeasuredOuputBelongsToAccess().getManagedDSLManagedIDTerminalRuleCall_3_0_1(), semanticObject.getManaged());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLMeasuredOutput
	 *     DSLMeasuredOutput returns DSLMeasuredOutput
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLMeasuredOutput(ISerializationContext context, DSLMeasuredOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLMonitorBelongsTo1
	 *     DSLMonitorBelongsTo1 returns DSLMonitorBelongsTo1
	 *
	 * Constraint:
	 *     (monitor=[DSLMonitor|ID] cl=[DSLControlLoop|ID])
	 */
	protected void sequence_DSLMonitorBelongsTo1(ISerializationContext context, DSLMonitorBelongsTo1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO1__MONITOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO1__MONITOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO1__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO1__CL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMonitorBelongsTo1Access().getMonitorDSLMonitorIDTerminalRuleCall_1_0_1(), semanticObject.getMonitor());
		feeder.accept(grammarAccess.getDSLMonitorBelongsTo1Access().getClDSLControlLoopIDTerminalRuleCall_3_0_1(), semanticObject.getCl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLMonitorBelongsTo2
	 *     DSLMonitorBelongsTo2 returns DSLMonitorBelongsTo2
	 *
	 * Constraint:
	 *     (monitor=[DSLMonitor|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLMonitorBelongsTo2(ISerializationContext context, DSLMonitorBelongsTo2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO2__MONITOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO2__MONITOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO2__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR_BELONGS_TO2__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMonitorBelongsTo2Access().getMonitorDSLMonitorIDTerminalRuleCall_1_0_1(), semanticObject.getMonitor());
		feeder.accept(grammarAccess.getDSLMonitorBelongsTo2Access().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLMonitor
	 *     DSLMonitor returns DSLMonitor
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLMonitor(ISerializationContext context, DSLMonitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLPlannerBelongsTo1
	 *     DSLPlannerBelongsTo1 returns DSLPlannerBelongsTo1
	 *
	 * Constraint:
	 *     (planner=[DSLPlanner|ID] cl=[DSLControlLoop|ID])
	 */
	protected void sequence_DSLPlannerBelongsTo1(ISerializationContext context, DSLPlannerBelongsTo1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO1__PLANNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO1__PLANNER));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO1__CL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO1__CL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLPlannerBelongsTo1Access().getPlannerDSLPlannerIDTerminalRuleCall_1_0_1(), semanticObject.getPlanner());
		feeder.accept(grammarAccess.getDSLPlannerBelongsTo1Access().getClDSLControlLoopIDTerminalRuleCall_3_0_1(), semanticObject.getCl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLPlannerBelongsTo2
	 *     DSLPlannerBelongsTo2 returns DSLPlannerBelongsTo2
	 *
	 * Constraint:
	 *     (planner=[DSLPlanner|ID] managing=[DSLManaging|ID])
	 */
	protected void sequence_DSLPlannerBelongsTo2(ISerializationContext context, DSLPlannerBelongsTo2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO2__PLANNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO2__PLANNER));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO2__MANAGING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER_BELONGS_TO2__MANAGING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLPlannerBelongsTo2Access().getPlannerDSLPlannerIDTerminalRuleCall_1_0_1(), semanticObject.getPlanner());
		feeder.accept(grammarAccess.getDSLPlannerBelongsTo2Access().getManagingDSLManagingIDTerminalRuleCall_3_0_1(), semanticObject.getManaging());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLPlanner
	 *     DSLPlanner returns DSLPlanner
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLPlanner(ISerializationContext context, DSLPlanner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLProbeBelongsTo
	 *     DSLProbeBelongsTo returns DSLProbeBelongsTo
	 *
	 * Constraint:
	 *     (probe=[DSLProbe|ID] managed=[DSLManaged|ID])
	 */
	protected void sequence_DSLProbeBelongsTo(ISerializationContext context, DSLProbeBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PROBE_BELONGS_TO__PROBE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PROBE_BELONGS_TO__PROBE));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PROBE_BELONGS_TO__MANAGED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PROBE_BELONGS_TO__MANAGED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLProbeBelongsToAccess().getProbeDSLProbeIDTerminalRuleCall_1_0_1(), semanticObject.getProbe());
		feeder.accept(grammarAccess.getDSLProbeBelongsToAccess().getManagedDSLManagedIDTerminalRuleCall_3_0_1(), semanticObject.getManaged());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLProbe
	 *     DSLProbe returns DSLProbe
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLProbe(ISerializationContext context, DSLProbe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLReferenceInputBelongsTo
	 *     DSLReferenceInputBelongsTo returns DSLReferenceInputBelongsTo
	 *
	 * Constraint:
	 *     (reference=[DSLReferenceInput|ID] knowledge=[DSLKnowledge|ID])
	 */
	protected void sequence_DSLReferenceInputBelongsTo(ISerializationContext context, DSLReferenceInputBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT_BELONGS_TO__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT_BELONGS_TO__REFERENCE));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT_BELONGS_TO__KNOWLEDGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT_BELONGS_TO__KNOWLEDGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLReferenceInputBelongsToAccess().getReferenceDSLReferenceInputIDTerminalRuleCall_1_0_1(), semanticObject.getReference());
		feeder.accept(grammarAccess.getDSLReferenceInputBelongsToAccess().getKnowledgeDSLKnowledgeIDTerminalRuleCall_3_0_1(), semanticObject.getKnowledge());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLReferenceInput
	 *     DSLReferenceInput returns DSLReferenceInput
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLReferenceInput(ISerializationContext context, DSLReferenceInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRestriction returns DSLRestriction
	 *
	 * Constraint:
	 *     (
	 *         (only=Only t=[DSLAbstraction|ID] can=Can elementType=ElementType type=[DSLAbstraction|ID]) | 
	 *         (t=[DSLAbstraction|ID] cannot=Cannot elementType=ElementType type=[DSLAbstraction|ID]) | 
	 *         (t=[DSLAbstraction|ID] can=Can elementType=ElementType type=[DSLAbstraction|ID]) | 
	 *         (t=[DSLAbstraction|ID] can=Can elementType=ElementType only2=Only2 type=[DSLAbstraction|ID]) | 
	 *         (t=[DSLAbstraction|ID] must=Must entityType=EntityType type=[DSLAbstraction|ID])
	 *     )
	 */
	protected void sequence_DSLRestriction(ISerializationContext context, DSLRestriction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLComposition returns DSLSensorBelongsTo
	 *     DSLSensorBelongsTo returns DSLSensorBelongsTo
	 *
	 * Constraint:
	 *     (sensor=[DSLSensor|ID] monitor=[DSLMonitor|ID])
	 */
	protected void sequence_DSLSensorBelongsTo(ISerializationContext context, DSLSensorBelongsTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_SENSOR_BELONGS_TO__SENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_SENSOR_BELONGS_TO__SENSOR));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_SENSOR_BELONGS_TO__MONITOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_SENSOR_BELONGS_TO__MONITOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLSensorBelongsToAccess().getSensorDSLSensorIDTerminalRuleCall_1_0_1(), semanticObject.getSensor());
		feeder.accept(grammarAccess.getDSLSensorBelongsToAccess().getMonitorDSLMonitorIDTerminalRuleCall_3_0_1(), semanticObject.getMonitor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAbstraction returns DSLSensor
	 *     DSLSensor returns DSLSensor
	 *
	 * Constraint:
	 *     (name=ID (interface+=ID interface+=ID*)?)
	 */
	protected void sequence_DSLSensor(ISerializationContext context, DSLSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementType returns EntityType
	 *     EntityType returns EntityType
	 *
	 * Constraint:
	 *     (entity='extend' | entity='implement' | entity='derive' | entity='throw' | entity='useannotation')
	 */
	protected void sequence_EntityType(ISerializationContext context, EntityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Must returns Must
	 *
	 * Constraint:
	 *     must='must-'
	 */
	protected void sequence_Must(ISerializationContext context, Must semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.MUST__MUST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.MUST__MUST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMustAccess().getMustMustKeyword_0(), semanticObject.getMust());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Only2 returns Only2
	 *
	 * Constraint:
	 *     only2='-only'
	 */
	protected void sequence_Only2(ISerializationContext context, Only2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.ONLY2__ONLY2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.ONLY2__ONLY2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnly2Access().getOnly2OnlyKeyword_0(), semanticObject.getOnly2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Only returns Only
	 *
	 * Constraint:
	 *     only='only'
	 */
	protected void sequence_Only(ISerializationContext context, Only semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.ONLY__ONLY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.ONLY__ONLY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnlyAccess().getOnlyOnlyKeyword_0(), semanticObject.getOnly());
		feeder.finish();
	}
	
	
}
