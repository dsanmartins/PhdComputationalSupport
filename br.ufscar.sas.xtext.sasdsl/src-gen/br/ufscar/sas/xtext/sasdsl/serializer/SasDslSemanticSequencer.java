/*
 * generated by Xtext 2.10.0
 */
package br.ufscar.sas.xtext.sasdsl.serializer;

import br.ufscar.sas.xtext.sasdsl.sasDsl.ArchitectureDefinition;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLAbstractions;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLControlLoop;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLControlLoopManager;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLEffector;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLGauge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLKnowledge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLManaged;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLManaging;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLMeasuredOutput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLPlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLProbe;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLReferenceInput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLSensor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.SasDslPackage;
import br.ufscar.sas.xtext.sasdsl.services.SasDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class SasDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SasDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SasDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SasDslPackage.ARCHITECTURE_DEFINITION:
				sequence_ArchitectureDefinition(context, (ArchitectureDefinition) semanticObject); 
				return; 
			case SasDslPackage.DCL_ABSTRACTIONS:
				sequence_DCLAbstractions(context, (DCLAbstractions) semanticObject); 
				return; 
			case SasDslPackage.DCL_ANALYZER:
				sequence_DCLAnalyzer(context, (DCLAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DCL_CONTROL_LOOP:
				sequence_DCLControlLoop(context, (DCLControlLoop) semanticObject); 
				return; 
			case SasDslPackage.DCL_CONTROL_LOOP_MANAGER:
				sequence_DCLControlLoopManager(context, (DCLControlLoopManager) semanticObject); 
				return; 
			case SasDslPackage.DCL_EFFECTOR:
				sequence_DCLEffector(context, (DCLEffector) semanticObject); 
				return; 
			case SasDslPackage.DCL_EXECUTOR:
				sequence_DCLExecutor(context, (DCLExecutor) semanticObject); 
				return; 
			case SasDslPackage.DCL_GAUGE:
				sequence_DCLGauge(context, (DCLGauge) semanticObject); 
				return; 
			case SasDslPackage.DCL_KNOWLEDGE:
				sequence_DCLKnowledge(context, (DCLKnowledge) semanticObject); 
				return; 
			case SasDslPackage.DCL_MANAGED:
				sequence_DCLManaged(context, (DCLManaged) semanticObject); 
				return; 
			case SasDslPackage.DCL_MANAGING:
				sequence_DCLManaging(context, (DCLManaging) semanticObject); 
				return; 
			case SasDslPackage.DCL_MEASURED_OUTPUT:
				sequence_DCLMeasuredOutput(context, (DCLMeasuredOutput) semanticObject); 
				return; 
			case SasDslPackage.DCL_MONITOR:
				sequence_DCLMonitor(context, (DCLMonitor) semanticObject); 
				return; 
			case SasDslPackage.DCL_PLANNER:
				sequence_DCLPlanner(context, (DCLPlanner) semanticObject); 
				return; 
			case SasDslPackage.DCL_PROBE:
				sequence_DCLProbe(context, (DCLProbe) semanticObject); 
				return; 
			case SasDslPackage.DCL_REFERENCE_INPUT:
				sequence_DCLReferenceInput(context, (DCLReferenceInput) semanticObject); 
				return; 
			case SasDslPackage.DCL_SENSOR:
				sequence_DCLSensor(context, (DCLSensor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArchitectureDefinition returns ArchitectureDefinition
	 *
	 * Constraint:
	 *     abstractions+=DCLAbstractions+
	 */
	protected void sequence_ArchitectureDefinition(ISerializationContext context, ArchitectureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLAbstractions
	 *
	 * Constraint:
	 *     managing+=DCLManaging
	 */
	protected void sequence_DCLAbstractions(ISerializationContext context, DCLAbstractions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLAnalyzer
	 *     DCLAnalyzer returns DCLAnalyzer
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLAnalyzer(ISerializationContext context, DCLAnalyzer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLControlLoopManager
	 *     DCLControlLoopManager returns DCLControlLoopManager
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLControlLoopManager(ISerializationContext context, DCLControlLoopManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLControlLoop
	 *     DCLControlLoop returns DCLControlLoop
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLControlLoop(ISerializationContext context, DCLControlLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLEffector
	 *     DCLEffector returns DCLEffector
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLEffector(ISerializationContext context, DCLEffector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLExecutor
	 *     DCLExecutor returns DCLExecutor
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLExecutor(ISerializationContext context, DCLExecutor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLGauge
	 *     DCLGauge returns DCLGauge
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLGauge(ISerializationContext context, DCLGauge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLKnowledge
	 *     DCLKnowledge returns DCLKnowledge
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLKnowledge(ISerializationContext context, DCLKnowledge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLManaged
	 *     DCLManaged returns DCLManaged
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLManaged(ISerializationContext context, DCLManaged semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLManaging returns DCLManaging
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLManaging(ISerializationContext context, DCLManaging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLMeasuredOutput
	 *     DCLMeasuredOutput returns DCLMeasuredOutput
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLMeasuredOutput(ISerializationContext context, DCLMeasuredOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLMonitor
	 *     DCLMonitor returns DCLMonitor
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLMonitor(ISerializationContext context, DCLMonitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLPlanner
	 *     DCLPlanner returns DCLPlanner
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLPlanner(ISerializationContext context, DCLPlanner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLProbe
	 *     DCLProbe returns DCLProbe
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLProbe(ISerializationContext context, DCLProbe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLReferenceInput
	 *     DCLReferenceInput returns DCLReferenceInput
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLReferenceInput(ISerializationContext context, DCLReferenceInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLAbstractions returns DCLSensor
	 *     DCLSensor returns DCLSensor
	 *
	 * Constraint:
	 *     (name+=ID name+=ID*)+
	 */
	protected void sequence_DCLSensor(ISerializationContext context, DCLSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
